component_list[-doesnt_have_species]
	#trimmed_list <- lapply(component_list[-doesnt_have_species], prune_species, )#
	for(i in 1:length(component_list)[-doesnt_have_species]){#
		print(class(component_list[i]))#
	}
(1:length(component_list))
(1:length(component_list))[-doesnt_have_species]
	#trimmed_list <- lapply(component_list[-doesnt_have_species], prune_species, )#
	for(i in (1:length(component_list))[-doesnt_have_species]){#
		print(class(component_list[i]))#
	}
	#trimmed_list <- lapply(component_list[-doesnt_have_species], prune_species, )#
	for(i in (1:length(component_list))[-doesnt_have_species]){#
		print(class(component_list[[i]]))#
	}
	trimmed_list <- component_list
# test this out.#
reconcile_species <- function(x){#
	# data(ex1)#
	# x <- ex2#
	component_list  <- splat.phyloseq.objects(x)#
	doesnt_have_species <- which( getslots.phyloseq(x) %in% c("sampleMap") )#
	species_vectors <- lapply(component_list[-doesnt_have_species], species.names)#
	keep_species <- Reduce("intersect", species_vectors)#
	trimmed_list <- component_list#
	for( i in (1:length(component_list))[-doesnt_have_species] ){#
		trimmed_list[[i]] <- prune_species(keep_species, component_list[[i]])#
	}#
	do.call("phyloseq", trimmed_list)#
}
intersect_species <- function(x){#
	# data(ex1)#
	# x <- ex2#
	component_list  <- splat.phyloseq.objects(x)#
	doesnt_have_species <- which( getslots.phyloseq(x) %in% c("sampleMap") )#
	species_vectors <- lapply(component_list[-doesnt_have_species], species.names)#
	return( Reduce("intersect", species_vectors) )#
}
intersect_species(ex2)
# otuTable related methods#
#################################################################################
#################################################################################
#' @name prune_species#
#' @aliases prune_species,logical,otuTable-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("logical", "otuTable"), function(species, x){#
	if( is.null(names(species)) ){#
		x <- prune_species(species.names(x)[species], x)#
	} else {#
		x <- prune_species(names(species)[species], x)#
	}#
	return(x)#
})#
#' @name prune_species#
#' @aliases prune_species,logical,otuTable-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "otuTable"), function(species, x){#
	species <- intersect( value, species.names(x) )#
	if( speciesarerows(x) ){#
		x[species, ]#
	} else {#
		x[, species]#
	}	#
})
#
intersect_species <- function(x){#
	# data(ex1)#
	# x <- ex2#
	component_list  <- splat.phyloseq.objects(x)#
	doesnt_have_species <- which( getslots.phyloseq(x) %in% c("sampleMap") )#
	species_vectors <- lapply(component_list[-doesnt_have_species], species.names)#
	return( Reduce("intersect", species_vectors) )#
}#
test_species <- intersect_species(x)
prune_species(otuTable(ex2), test_species)
prune_species(test_species, otuTable(ex2))
#' @rdname prune_species-methods
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "otuTable"), function(species, x){#
	species <- intersect( species, species.names(x) )#
	if( speciesarerows(x) ){#
		x[species, ]#
	} else {#
		x[, species]#
	}	#
})
prune_species(test_species, otuTable(ex2))
#################################################################################
# otuTable related methods#
#################################################################################
#################################################################################
#' @name prune_species#
#' @aliases prune_species,logical,otuTable-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("logical", "otuTable"), function(species, x){#
	# convert the logical argument to character and dispatch#
	if( is.null(names(species)) ){#
		species <- species.names(x)[species]#
	} else {#
		species <- names(species)[species]#
	}#
	prune_species(species, x)#
})#
#' @name prune_species#
#' @aliases prune_species,logical,otuTable-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "otuTable"), function(species, x){#
	species <- intersect( species, species.names(x) )#
	if( speciesarerows(x) ){#
		x[species, ]#
	} else {#
		x[, species]#
	}	#
})
prune_species(test_species, otuTable(ex2))
intersect_species <- function(x){#
	# data(ex1)#
	# x <- ex2#
	component_list  <- splat.phyloseq.objects(x)#
	doesnt_have_species <- which( getslots.phyloseq(x) %in% c("sampleMap") )#
	species_vectors <- lapply(component_list[-doesnt_have_species], species.names)#
	return( Reduce("intersect", species_vectors) )#
}#
test_species <- intersect_species(x)#
prune_species(test_species, otuTable(ex2))
library(phylobase)
?read.tree
?readNexus
library("devtools")
library("phyloseq")
?otuTable
?document
?library("devtools")
library("devtools")
?document
?roxygenise
library("roxygen2")
?roxygenise
library('phyloseq')
?otuTable-class
otuTable?class
class?otuTable
library("phyloseq")
datat(ex1)
data(ex1)
species <- intersect_species(ex1)
length(species)
species == species.names(ex1)
all(species == species.names(ex1))
c(rep(TRUE,1000),FALSE)
any(c(rep(TRUE,1000),FALSE))
all(c(rep(TRUE,1000),FALSE))
nspeces(ex1)
nspecies(ex1)
length(species) == nspecies
length(species) == nspecies(ex1)
identical(species, species.names(ex1))
?identical
identical(species, sample(species, length(species)))
nsamples(ex1)
#################################################################################
#' Returns the intersection of species for the components of x#
#'#
#' This function is used internally as part of the infrastructure to ensure that#
#' component data types in a phyloseq-object have exactly the same taxa/species.#
#' It relies heavily on the \code{\link{Reduce}} function to determine the #
#' strictly common species.#
#'#
#' @param x An object of the phyloseq package that contains 2 or more components#
#'  data tables that in-turn describe species/taxa. E.g. An otuTree object, or#
#'  an otuTax object.#
#'#
#' @return Returns a character vector of only those species that are present in#
#'  all species-describing components of \code{x}.#
#'#
#' @seealso \code{\link{reconcile_species}}, \code{\link{Reduce}}#
#' @export#
#' @examples ##
#' ## data(ex1)#
#' ## head(intersect_species(ex1), 10)#
intersect_species <- function(x){#
	component_list  <- splat.phyloseq.objects(x)#
	doesnt_have_species <- which( getslots.phyloseq(x) %in% c("sampleMap") )#
	if( length(doesnt_have_species) > 0 ){#
		species_vectors <- lapply(component_list[-doesnt_have_species], species.names)		#
	} else {#
		species_vectors <- lapply(component_list, species.names)		#
	}#
	return( Reduce("intersect", species_vectors) )#
}#
#################################################################################
#' Keep only species-indices common to all components.#
#'#
#' This function is used internally as part of the infrastructure to ensure that#
#' component data types in a phyloseq-object have exactly the same taxa/species.#
#' It relies heavily on the \code{\link{prune_species}} S4 methods to perform the#
#' actual trimming. In expected cases, a user will not need to invoke this#
#' function, because phyloseq objects are reconciled during instantiation by#
#' default.#
#'#
#' @param x An object of the phyloseq package that contains 2 or more components#
#'  data tables that in-turn describe species/taxa. E.g. An otuTree object, or#
#'  an otuTax object.#
#'#
#' @return A trimmed version of the argument, \code{x}, in which each component#
#'  describes exactly the same set of species/taxa. Class of \code{x} should be#
#'  unchanged.#
#'#
#' @seealso \code{\link{reconcile_samples}}, \code{\link{Reduce}}#
#' @export#
#' @examples ##
#' ## data(ex1)#
#' ## head(intersect_species(ex1), 10)#
#' ## reconcile_species(ex1)#
reconcile_species <- function(x){#
	species <- intersect_species(x)#
	# prevent infinite recursion issues by checking if intersection already satisfied#
	if( identical(length(species), nspecies(x)) ){#
		return(x)#
	}#
	slots2reconcile <- names(getslots.phyloseq(x))#
	for( i in slots2reconcile ){#
		eval(parse(text=paste("x@", i, "<- prune_species(species, x@", i, ")", sep="")))#
	}#
	return(x)#
}#
#################################################################################
#' Keep only sample-indices common to all components.#
#'#
#' This function is used internally as part of the infrastructure to ensure that#
#' component data types in a phyloseq-object describe exactly the same samples.#
#' In expected cases, a user will not need to invoke this#
#' function, because phyloseq objects are reconciled during instantiation by#
#' default.#
#'#
#' @param x An object of the phyloseq package that contains 2 or more components#
#'  data tables that in-turn describe samples. At present this is limited to #
#'  the otuSam class (otuTable and SampleMap) and its children.#
#'#
#' @return A trimmed version of the argument, \code{x}, in which each component#
#'  describes exactly the same set of samples. Class of \code{x} should be#
#'  unchanged.#
#'#
#' @seealso \code{\link{reconcile_species}}#
#' @export#
#' @examples ##
#' ## data(ex1)#
#' ## reconcile_samples(ex1)#
reconcile_samples <- function(x){#
	samples <- intersect(rownames(x@sampleMap), sample.names(x@otuTable))#
	# prevent infinite recursion issues by checking if intersection already satisfied#
	if( identical(length(samples), nsamples(x)) ){#
		return(x)#
	}			#
	x@sampleMap <- prune_samples(samples, x@sampleMap)#
	x@otuTable  <- prune_samples(samples, x@otuTable)#
	return(x)#
}
library("phyloseq")
data(ex1)
access(ex1, "otuTable")
x3
x2
x2 <- otuSam(ex1)
x2
access(x2, "otuTable")
access(x2, "taxTab")
x <- otuSam(ex1)
if( !is.null(access(x, "taxTab")) ){x@taxTab <- prune_species(species, x)}
!is.null(access(x, "tre"))
x@tre
#################################################################################
#' @name prune_species#
#' @aliases prune_species,character,phyloseqFather-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "phyloseqFather"), #
		function(species, x){#
#
	if( !is.null(access(x, "otuTable")) ){#
		x@otuTable  <- prune_species(species, x@otuTable)#
	}#
	if( !is.null(access(x, "sampleMap")) ){#
		x@sampleMap <- prune_species(species, x@sampleMap)#
	}#
	if( !is.null(access(x, "taxTab")) ){#
		x@taxTab    <- prune_species(species, x@taxTab)#
	}#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
#
})
prune_species(species.names(x), x)
x
taxTab(x)
access
taxTab
#' @name prune_species#
#' @aliases prune_species,character,phyloseqFather-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "phyloseqFather"), #
		function(species, x){#
	# Test if slot is present. If so, perform the component prune.#
	if( !is.null(access(x, "otuTable")) ){#
		x@otuTable  <- prune_species(species, x@otuTable)#
	}#
	if( !is.null(access(x, "sampleMap")) ){#
		x@sampleMap <- prune_species(species, x@sampleMap)#
	}#
	if( !is.null(access(x, "taxTab")) ){#
		x@taxTab    <- prune_species(species, x@taxTab)#
	}#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
	return(x)#
})
prune_species(species.names(x), x)
prune_species(species.names(x)[1:100], x)
?intersect
species
species <- species.names(x)[1:100]
species.names(x)
setdiff(species, species.names(x)[1:100])
?empty
setequal(species, species.names(x)[1:100])
setequal(species, species.names(x))
species
species.names(x)
library("phyloseq")
data(ex1)
x2 <- ex1
prune_species(species.names(x2)[1:100], x2)
species <- species.names(x2)[1:100]
prune_species(species, x2)
x2@otuTable <- prune_species(species, x2@otuTable)
x2@taxTab <- prune_species(species, x2@taxTab)
x2
x2@tre <- prune_species(species, x2@tre)
x2
phyloseqFather?prune_species
prune_species?character,phyloseqFather
prune_species?character-phyloseqFather
prune_species?character?phyloseqFather
prune_species?character
?prune_species
?library
setMethod("prune_species", signature("character", "phyloseqFather"), #
		function(species, x){#
	# All phyloseqFather children have an otuTable slot, no need to test.#
	x@otuTable <- prune_species(species, x@otuTable)#
	#
	# Test if slot is present. If so, perform the component prune.#
	if( !is.null(access(x, "taxTab")) ){#
		x@taxTab    <- prune_species(species, x@taxTab)#
	}#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
	return(x)#
})
prune_species(species, x2)
setMethod("prune_species", signature("character", "phyloseqFather"), #
		function(species, x){#
	print("This is the method.")#
	# All phyloseqFather children have an otuTable slot, no need to test.#
	x@otuTable <- prune_species(species, x@otuTable)#
	#
	# Test if slot is present. If so, perform the component prune.#
	if( !is.null(access(x, "taxTab")) ){#
		x@taxTab    <- prune_species(species, x@taxTab)#
	}#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
	return(x)#
})
prune_species(species, x2)
getMethod(prune_species, "otuSam")
getMethod(prune_species, signature("character", "otuSam"))
?getMethod
getMethod(prune_species, c("character", "otuSam"))
getMethod(prune_species, "otuTable")
x3 <- otuTable(ex1)
x3[1:100, ]
x4 <- ex1
otuTable(x4) <- x3[1:100, ]
x4
species.names(x3[1:100, ])
species.names(x3)
species.names(x2)
?parse
data.frame(x=1:10, expression(y=1:10))
data.frame(x=1:10, eval(expression(y=1:10)))
data.frame(x=1:10, within(expression(y=1:10)))
data.frame(x=1:10, evalq(expression(y=1:10)))
data.frame(x=1:10, quote(expression(y=1:10)))
quote(expression(y=1:!0))
quote(expression(y=1:10))
y <-
quote(expression(y=1:10))
y
class(y)
eval(y)
class(eval(y))
data.frame(x=1:10, eval(quote(expression(y=1:10))))
x <- data.frame(x=1:10, z=1:10)
x
transform(x, quote(expression(y=1:10)))
w
w<- quote(expression(y=1:10))
w
transform(x, y=1:10)
transform(x, y=1:10, w=1:10)
transform(x, w)
x
transform(x, eval(w))
transform(x, evalq(w))
transform(x, unquote(w))
?quote
deparse(w)
w
class(w)
w<-expression(y=1:10)
w
deparse(w)
w=quote(y=1:10)
?quote
eval(y=1:10)
expression(y=1:10)
w<-expression(y=1:10)
w
class(w)
call(w)
quote(w)
quote(eval(w))
wtf <- expression(y=1:10)
eval(wtf)
class(wtf)
call(wtf)
as.call(wtf)
wtf
deparse
deparse(wtf)
parse(text=deparse(wtf))
call(parse(text=deparse(wtf)))
call(parse(text=deparse(wtf, control="all")))
parse(text=deparse(wtf), control="all")
parse(text=deparse(wtf, control="all"))
deparse(wtf, control="all")
deparse(wtf, control="")
deparse(wtf, control="keepInteger")
wtf
class(wtf)
as.list(wtf)
x
do.call("transform", c(list(x), as.list(wtf)))
setGeneric('myfun', function(x, y) standardGeneric('myfun'))#
setMethod('myfun',c('data.frame', 'expression'), function(x, y){#
	do.call("transform", c(list(x), as.list(y)))#
})#
# try out the new method#
z <- expression(NewVar = Petal.Width*Petal.Length)#
test <- myfun(iris, z)#
names(test)
do.call()
test
?error
?check
prune_species(species, x2)
foo <- function(species, x){#
	print("This is the method.")#
	# All phyloseqFather children have an otuTable slot, no need to test.#
	x@otuTable <- prune_species(species, x@otuTable)#
	#
	# Test if slot is present. If so, perform the component prune.#
	if( !is.null(access(x, "taxTab")) ){#
		x@taxTab    <- prune_species(species, x@taxTab)#
	}#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
	return(x)#
}
x2
species
x1 <- ex1
foo(species, x1)
prune_species(species, x2)
prune_species(species, x1)
#################################################################################
#' @name prune_species#
#' @aliases prune_species,character,otuTree-method#
#' @docType methods#
#' @rdname prune_species-methods#
setMethod("prune_species", signature("character", "otuTree"), function(species, x){#
	if( !is.null(access(x, "tre")) ){#
		x@tre       <- prune_species(species, x@tre)#
	}#
	return(x)#
})
prune_species(species, x1)
library("phylsoeq")
library("phyloseq")
x1<-ex1
data(ex1)
x1<-ex1
prune_species(x1, species.names(x1)[1:100])
prune_species(species.names(x1)[1:100], x1)
library("devtools")
install_github("phyloseq", "joey711")
library("phyloseq")
data(ex1)
calcplot(ex1 ~ Diet + Gender)
calcplot(ex1)
calcplot(ex1~)
calcplot(ex1~Diet)
X <- ex1~Diet
X
RDA_or_CCA="cca"
object=get(all.vars(X)[1])
object
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}
mod
	ord_vars <- all.vars(X)[-1]
ord_vars
	# default is to use the R.H.S. elements of X as color and shape#
	plot_ordination_phyloseq(mod,#
		object = object, #
		site_shape_category = ord_vars[1],#
		site_color_category = ord_vars[2]#
	)
ex1~
ex1~laskdjflask
ex1~.
 X <- ex1~.
	ord_vars <- all.vars(X)[-1]
	ord_vars
plot_ordination_phyloseq(mod, object)
	list(mod=mod, object=object)
X <- ex1~Diet
all.vars(X)[-1]
	popcall
X <- ex1~Diet #
RDA_or_CCA="cca"#
object=get(all.vars(X)[1])#
#
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}#
#
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	popcallList
X <- ex1~Diet + Sex
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	popcallList
X <- ex1~Diet + Sex#
RDA_or_CCA="cca"#
object=get(all.vars(X)[1])#
#
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}#
#
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	do.call("plot_ordination_phyloseq", popcallList)
X <- ex1~Diet + Gender#
RDA_or_CCA="cca"#
object=get(all.vars(X)[1])#
#
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}#
#
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	do.call("plot_ordination_phyloseq", popcallList)
X <- ex1 ~ Diet#
RDA_or_CCA="cca"#
object=get(all.vars(X)[1])#
#
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}#
#
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	do.call("plot_ordination_phyloseq", popcallList)
X <- ex1 ~ .#
RDA_or_CCA="cca"#
object=get(all.vars(X)[1])#
#
	if( substr(RDA_or_CCA, 1, 1) %in% c("R", "r") ){#
		mod <- rda.phyloseq(X)		#
	} else if( substr(RDA_or_CCA, 1, 1) %in% c("C", "c") ){#
		mod <- cca.phyloseq(X)		#
	} else {#
		cat("You did not properly specify the desired ordination method\n")#
		cat("Please see documentation.\n")		#
		return()#
	}#
#
	# X <- ex1~.#
	ord_vars <- all.vars(X)[-1]#
#
	# Initialize call list for plot_ordination_phyloseq#
	popcallList <- list(mod=mod, object=object)#
#
	if( ord_vars[1] != "."){#
		popcallList <- c(popcallList, list(site_color_category = ord_vars[1]))#
	} #
	if( length(ord_vars) > 1){#
		popcallList <- c(popcallList, list(site_shape_category = ord_vars[2]))#
	}#
	#
	do.call("plot_ordination_phyloseq", popcallList)
?warning
class(ex1~.)
?formula
